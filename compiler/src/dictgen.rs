//! 辞書生成モジュール
//!
//! このモジュールは、訓練されたモデルから形態素解析用の辞書ファイル群を生成する機能を提供します。
//! 語彙ファイル(lex.csv)、連接コスト定義ファイル(matrix.def)、未知語定義ファイル(unk.def)、
//! およびオプションでバイグラム情報ファイルを出力します。

use std::fs::File;
use std::io::{self, Write};
use std::path::{Path, PathBuf};

use clap::Parser;
use vibrato_rkyv::errors::VibratoError;
use vibrato_rkyv::trainer::Model;

/// ファイルベースの辞書ライタ型エイリアス
///
/// すべてのライタがファイルである場合の型を簡略化します。
pub type FileDictionaryWriters = DictionaryWriters<File, File, File, File, File, File, File>;

/// 辞書生成コマンドの引数
///
/// モデルファイルの入力パスと、生成する辞書ファイルの出力パスを指定します。
#[derive(Parser, Debug)]
#[clap(name = "dictgen", about = "Dictionary generator")]
pub struct Args {
    /// Model file generated by the train command (in zstd).
    #[clap(short = 'i', long)]
    model_in: PathBuf,

    /// A file to which the system lexicon is output (lex.csv).
    #[clap(short = 'l', long)]
    lexicon_out: PathBuf,

    /// A file to which the unknown word definition is output (unk.def).
    #[clap(short = 'u', long)]
    unk_out: PathBuf,

    /// A file to which the matrix is output (matrix.def).
    #[clap(short = 'm', long)]
    matrix_out: PathBuf,

    /// User-defined lexicon file. For which you want to give weights automatically,
    /// set 0 for the connection ID and the weight of such entries.
    #[clap(long)]
    user_lexicon_in: Option<PathBuf>,

    /// A file to which the user-defined lexicon is output.
    #[clap(long)]
    user_lexicon_out: Option<PathBuf>,

    /// Outputs a list of features associated with each connection ID and a list of bi-gram
    /// costs.
    ///
    /// The file names are suffixed with `.left`, `.right`, and `.cost`.
    #[clap(long)]
    conn_id_info_out: Option<PathBuf>,
}

/// 辞書生成処理中に発生する可能性のあるエラー
#[derive(Debug, thiserror::Error)]
pub enum DictgenError {
    /// 入出力エラー
    #[error("I/O error: {0}")]
    Io(#[from] io::Error),

    /// モデル処理エラー
    #[error("Failed to process the model: {0}")]
    Model(#[from] VibratoError),
}

/// 接続ID情報を書き込むためのライタ群
///
/// バイグラム情報(left, right, cost)を書き込むためのライタを保持します。
#[derive(Debug, Clone)]
pub struct ConnIdInfoWriters<LW: Write, RW: Write, CW: Write> {
    /// 左接続ID情報のライタ
    pub left_wtr: LW,
    /// 右接続ID情報のライタ
    pub right_wtr: RW,
    /// バイグラムコストのライタ
    pub cost_wtr: CW,
}

/// 辞書ファイルを書き込むためのライタ群
///
/// 辞書生成に必要なすべてのファイルへのライタを保持します。
#[derive(Debug, Clone)]
pub struct DictionaryWriters<L, C, U, S, LW, RW, CW>
where
    L: Write, C: Write, U: Write, S: Write,
    LW: Write, RW: Write, CW: Write,
{
    /// 語彙ファイル(lex.csv)のライタ
    pub lexicon_wtr: L,
    /// 連接コスト定義ファイル(matrix.def)のライタ
    pub matrix_wtr: C,
    /// 未知語定義ファイル(unk.def)のライタ
    pub unk_wtr: U,
    /// ユーザー辞書ファイルのライタ(オプション)
    pub user_lexicon_wtr: Option<S>,
    /// 接続ID情報ファイルのライタ群(オプション)
    pub conn_id_info_wtrs: Option<ConnIdInfoWriters<LW, RW, CW>>,
}


/// 辞書生成コマンドを実行する
///
/// モデルファイルを読み込み、辞書ファイル群を生成します。
///
/// # 引数
///
/// * `args` - 辞書生成コマンドの引数
///
/// # 戻り値
///
/// 成功時は`Ok(())`
///
/// # エラー
///
/// ファイルの読み書きやモデル処理に失敗した場合、`DictgenError`を返します。
pub fn run(args: Args) -> Result<(), DictgenError> {
    let model_rdr = zstd::Decoder::new(File::open(args.model_in)?)?;
    let mut model = Model::read_model(model_rdr)?;

    let mut sources = create_dictionary_writers_from_paths(
        &args.lexicon_out,
        &args.matrix_out,
        &args.unk_out,
        args.user_lexicon_out.as_deref(),
        args.conn_id_info_out.as_deref(),
    )?;

    generate_dictionary_files(&mut model, &mut sources)?;

    Ok(())
}

/// 指定されたパスから辞書ライタ群を作成する
///
/// # 引数
///
/// * `lexicon_out_path` - 語彙ファイル(lex.csv)の出力パス
/// * `matrix_out_path` - 連接コスト定義ファイル(matrix.def)の出力パス
/// * `unk_out_path` - 未知語定義ファイル(unk.def)の出力パス
/// * `user_lexicon_out_path` - ユーザー辞書ファイルの出力パス(オプション)
/// * `conn_id_info_out_path` - 接続ID情報ファイルのベース名(オプション)
///   `.left`, `.right`, `.cost`の接尾辞が付加されます
///
/// # 戻り値
///
/// 作成されたファイルライタ群
///
/// # エラー
///
/// ファイルの作成に失敗した場合、`io::Error`を返します。
pub fn create_dictionary_writers_from_paths(
    lexicon_out_path: &Path,
    matrix_out_path: &Path,
    unk_out_path: &Path,
    user_lexicon_out_path: Option<&Path>,
    conn_id_info_out_path: Option<&Path>,
) -> Result<
    FileDictionaryWriters,
    io::Error,
> {
    let lexicon_wtr = File::create(lexicon_out_path)?;
    let matrix_wtr = File::create(matrix_out_path)?;
    let unk_wtr = File::create(unk_out_path)?;

    let user_lexicon_wtr = user_lexicon_out_path.map(File::create).transpose()?;

    let conn_id_info_wtrs = conn_id_info_out_path
        .map(|path| -> io::Result<_> {
            let base_name = path.as_os_str().to_os_string();
            let mut left_path = base_name.clone();
            left_path.push(".left");
            let mut right_path = base_name.clone();
            right_path.push(".right");
            let mut cost_path = base_name;
            cost_path.push(".cost");
            Ok(ConnIdInfoWriters {
                left_wtr: File::create(left_path)?,
                right_wtr: File::create(right_path)?,
                cost_wtr: File::create(cost_path)?,
            })
        })
        .transpose()?;

    Ok(DictionaryWriters {
        lexicon_wtr,
        matrix_wtr,
        unk_wtr,
        user_lexicon_wtr,
        conn_id_info_wtrs,
    })
}

/// モデルから辞書ファイル群を生成する
///
/// # 引数
///
/// * `model` - 訓練されたモデル
/// * `writers` - 辞書ファイルを書き込むライタ群
///
/// # 戻り値
///
/// 成功時は`Ok(())`
///
/// # エラー
///
/// 辞書ファイルの生成に失敗した場合、`VibratoError`を返します。
pub fn generate_dictionary_files<L, C, U, S, LW, RW, CW>(
    model: &mut Model,
    writers: &mut DictionaryWriters<L, C, U, S, LW, RW, CW>,
) -> Result<(), VibratoError>
where
    L: Write, C: Write, U: Write, S: Write,
    LW: Write, RW: Write, CW: Write,
{
    if let Some(user_wtr) = writers.user_lexicon_wtr.as_mut() {
        model.write_dictionary(
            &mut writers.lexicon_wtr,
            &mut writers.matrix_wtr,
            &mut writers.unk_wtr,
            user_wtr,
        )?;
    } else {
        model.write_dictionary(
            &mut writers.lexicon_wtr,
            &mut writers.matrix_wtr,
            &mut writers.unk_wtr,
            io::sink(),
        )?;
    }

    if let Some(bigram_info) = writers.conn_id_info_wtrs.as_mut() {
        model.write_bigram_details(
            &mut bigram_info.left_wtr,
            &mut bigram_info.right_wtr,
            &mut bigram_info.cost_wtr,
        )?;
    }

    Ok(())
}
